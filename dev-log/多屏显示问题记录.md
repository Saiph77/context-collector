# Context Collector 多屏显示问题记录

## 问题重新定义（2025-08-23 更新）

**重要发现**：问题不是物理多显示器，而是**Mission Control的多桌面空间（Spaces）**问题！

### 真实问题描述
- **Space 1**：桌面空间
- **Space 2**：全屏IDEA
- **Space 3**：全屏Chrome
- **问题**：当在Space 2或Space 3中使用快捷键时，窗口只出现在Space 1，而不是当前活跃的Space

### 之前的误解
之前误认为是物理多显示器问题，实际上是Mission Control虚拟桌面的问题。

## 已尝试的解决方案

### 1. 窗口层级提升（三次迭代）✅ 部分成功

#### 第一次：.popUpMenu → .modalPanel
```swift
window?.level = .modalPanel
```
**结果**：能覆盖全屏应用，但Space问题未解决

#### 第二次：.modalPanel → .popUpMenu （发现层级错误）
```swift
window?.level = .popUpMenu  // 层级101，实际比.modalPanel更高
```
**结果**：仍然无法解决Space问题

#### 第三次：.popUpMenu → .screenSaver （最高层级）
```swift
window?.level = .screenSaver  // 层级1000，最高优先级
```
**结果**：依然无法在不同Space中显示

### 2. 实现鼠标附近定位 ✅ 成功
**问题**：窗口总是居中显示，不在鼠标附近
**解决方案**：替换`window?.center()`为自定义的`positionWindowNearMouse()`方法
```swift
// 文件：Sources/main.swift:37
// 修改前：
window?.center()

// 修改后：
positionWindowNearMouse()
```
**结果**：成功实现窗口在鼠标附近显示

### 3. Mission Control Spaces 解决尝试 ❌ 均失败

#### 尝试方案一：NSWindowCollectionBehavior组合
```swift
// 基础组合
window?.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]

// 增强组合
window?.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary, .stationary]
```
**结果**：窗口仍然只在Space 1显示

#### 尝试方案二：.moveToActiveSpace属性 ❌ 导致崩溃
```swift
window?.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary, .moveToActiveSpace]
```
**结果**：应用崩溃，此属性可能不存在或已弃用

#### 尝试方案三：orderFrontRegardless()强制显示
```swift
window?.orderFrontRegardless()  // 替代makeKeyAndOrderFront
```
**结果**：导致应用不稳定，后恢复为makeKeyAndOrderFront

### 4. 窗口位置闪现问题 ✅ 已解决
**问题**：窗口先在左下角显示，然后跳跃到鼠标附近
**解决方案**：重构窗口创建流程
```swift
// 原流程：创建→显示→延迟定位
// 新流程：计算位置→在正确位置创建→显示

let targetFrame = calculateWindowPosition()
window = NSWindow(contentRect: targetFrame, ...)
```
**结果**：✅ 窗口直接在正确位置显示，无闪烁

### 5. 屏幕检测问题（物理多屏）✅ 已解决

#### 尝试方案一：修复NSMouseInRect参数
**假设**：`NSMouseInRect`的第三个参数（坐标系统翻转）可能导致检测错误
```swift
// 修改前：
let currentScreen = NSScreen.screens.first { screen in
    NSMouseInRect(mouseLocation, screen.frame, false)
} ?? NSScreen.main ?? NSScreen.screens.first!

// 修改后：
let currentScreen = NSScreen.screens.first { screen in
    screen.frame.contains(mouseLocation)
} ?? NSScreen.main ?? NSScreen.screens.first!
```
**结果**：未解决问题

#### 尝试方案二：双重检测策略
**假设**：可能需要分别检测`visibleFrame`和`frame`
```swift
// 使用更直接的方法获取鼠标所在屏幕
var currentScreen: NSScreen?
for screen in NSScreen.screens {
    // 使用visibleFrame进行检测，这更准确反映实际可用区域
    if screen.visibleFrame.contains(mouseLocation) {
        currentScreen = screen
        break
    }
}

// 如果在visibleFrame中没找到，再用frame试试
if currentScreen == nil {
    for screen in NSScreen.screens {
        if screen.frame.contains(mouseLocation) {
            currentScreen = screen
            break
        }
    }
}

// 最后的回退选项
if currentScreen == nil {
    currentScreen = NSScreen.main ?? NSScreen.screens.first!
}
```
**结果**：仍未解决问题

## 当前代码状态（最新版本）

### 窗口创建流程（已优化）
```swift
func showCaptureWindow() {
    // 先计算窗口应该出现的位置
    let targetFrame = calculateWindowPosition()
    
    window = NSWindow(
        contentRect: targetFrame,  // 直接在正确位置创建
        styleMask: [.titled, .closable, .miniaturizable],
        backing: .buffered,
        defer: false
    )
    
    window?.title = "Context Collector"
    window?.contentView = NSHostingView(rootView: captureView)
    window?.level = .screenSaver  // 最高层级
    window?.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary, .stationary]
    window?.makeKeyAndOrderFront(nil)
    
    NSApp.activate(ignoringOtherApps: true)
}
```

### calculateWindowPosition方法（新增）
```swift
private func calculateWindowPosition() -> NSRect {
    let mouseLocation = NSEvent.mouseLocation
    
    // 检测鼠标所在屏幕
    var currentScreen: NSScreen?
    for screen in NSScreen.screens {
        if screen.frame.contains(mouseLocation) {
            currentScreen = screen
            break
        }
    }
    if currentScreen == nil {
        currentScreen = NSScreen.main ?? NSScreen.screens.first!
    }
    
    let screen = currentScreen!
    let screenFrame = screen.visibleFrame
    let scaleFactor = screen.backingScaleFactor
    let baseOffset: CGFloat = 20
    let offset = baseOffset / scaleFactor
    
    // 窗口尺寸
    let windowSize = NSSize(width: 800, height: 500)
    
    // 计算位置并进行边界检测
    var targetX = mouseLocation.x + offset
    var targetY = mouseLocation.y - windowSize.height - offset
    
    // 边界检测逻辑...
    
    return NSRect(x: targetX, y: targetY, width: windowSize.width, height: windowSize.height)
}
```

### positionWindowNearMouse方法（保留用于调试）
```swift
private func positionWindowNearMouse() {
    guard let window = window else { return }
    
    // 获取当前鼠标位置
    let mouseLocation = NSEvent.mouseLocation
    print("🖱️ 鼠标位置: \(mouseLocation)")
    
    // 使用更直接的方法获取鼠标所在屏幕
    var currentScreen: NSScreen?
    for screen in NSScreen.screens {
        // 使用visibleFrame进行检测，这更准确反映实际可用区域
        if screen.visibleFrame.contains(mouseLocation) {
            currentScreen = screen
            break
        }
    }
    
    // 如果在visibleFrame中没找到，再用frame试试
    if currentScreen == nil {
        for screen in NSScreen.screens {
            if screen.frame.contains(mouseLocation) {
                currentScreen = screen
                break
            }
        }
    }
    
    // 最后的回退选项
    if currentScreen == nil {
        currentScreen = NSScreen.main ?? NSScreen.screens.first!
    }
    
    print("🖥️ 检测到的屏幕: \(currentScreen!.visibleFrame)")
    print("🖥️ 主屏幕对比: \(NSScreen.main?.visibleFrame ?? NSRect.zero)")
    
    // 窗口尺寸
    let windowSize = window.frame.size
    
    // 使用检测到的屏幕的可见区域进行定位
    let screenFrame = currentScreen!.visibleFrame
    
    // 计算目标位置（鼠标右下方偏移）
    let offset: CGFloat = 20
    var targetX = mouseLocation.x + offset
    var targetY = mouseLocation.y - windowSize.height - offset
    
    // 边界检测 - X轴
    if targetX + windowSize.width > screenFrame.maxX {
        // 如果右侧超出边界，放到鼠标左侧
        targetX = mouseLocation.x - windowSize.width - offset
    }
    if targetX < screenFrame.minX {
        // 如果左侧也超出，就居中到当前屏幕
        targetX = screenFrame.midX - windowSize.width / 2
    }
    
    // 边界检测 - Y轴
    if targetY < screenFrame.minY {
        // 如果下方超出边界，放到鼠标上方
        targetY = mouseLocation.y + offset
    }
    if targetY + windowSize.height > screenFrame.maxY {
        // 如果上方也超出，就居中到当前屏幕
        targetY = screenFrame.midY - windowSize.height / 2
    }
    
    let targetFrame = NSRect(x: targetX, y: targetY, width: windowSize.width, height: windowSize.height)
    window.setFrame(targetFrame, display: true)
    
    print("✅ 窗口定位到: \(targetFrame)")
    print("📍 是否在检测屏幕内: \(screenFrame.intersects(targetFrame))")
}
```

## 核心技术难点和未解决问题

### 1. Mission Control Spaces 显示问题 ❌ 核心问题
**现状**：即使使用最高窗口层级（.screenSaver）和最强Space行为组合，窗口仍然无法在全屏应用的Space中显示

**已尝试的方案**：
- 所有可能的`NSWindowCollectionBehavior`组合
- 最高的窗口层级（.screenSaver, 层级1000）
- 不同的窗口显示方法（makeKeyAndOrderFront vs orderFrontRegardless）

**可能的原因**：
- macOS的全屏Space可能有特殊的窗口隔离机制
- 可能需要使用私有API或系统级调用
- 全屏应用可能会阻止其他窗口在其Space中显示

### 2. 物理多屏检测问题 ✅ 已解决
- ~~**macOS屏幕坐标系统**~~：已理解原点在左下角，Y轴向上为正
- ~~**NSEvent.mouseLocation**~~：已正确使用全局屏幕坐标
- ~~**屏幕检测方法**~~：已使用`screen.frame.contains(mouseLocation)`成功检测

### 3. 窗口位置闪现问题 ✅ 已解决  
- ~~**延迟定位问题**~~：已通过预计算位置解决
- ~~**视觉跳跃效果**~~：已消除，窗口直接在正确位置创建

## 可能的原因分析

### 1. 坐标系统转换问题
可能需要进行坐标系统转换，特别是在多屏环境下，不同屏幕可能有不同的坐标基准点。

### 2. 屏幕排列配置
macOS中屏幕的物理排列可能影响坐标计算，主屏幕不一定是坐标原点。

### 3. API使用错误
可能需要使用其他API，如：
- `NSScreen.deepest(for: point)`
- 或者通过`CGWindowListCopyWindowInfo`等底层API

### 4. 时机问题
可能在窗口创建的时机进行屏幕检测存在问题，需要在不同的生命周期阶段进行检测。

## 建议进一步调查的方向

### Mission Control Spaces问题的可能解决途径

1. **私有API研究**：
   - 研究CGSPrivate.h中的Space管理API
   - 使用`CGSGetActiveSpace()`, `CGSMoveWindowToSpace()`等函数
   - 风险：App Store审核不通过，系统更新可能失效

2. **Accessibility API**：
   - 使用AXUIElement检测当前活跃应用和Space状态
   - 监听Space切换事件
   - 动态调整窗口行为

3. **更深层的窗口行为研究**：
   - 研究成功的开源项目：Rectangle, Hammerspoon等
   - 分析其他能在全屏Space显示的应用实现方式
   - 可能存在未知的NSWindowCollectionBehavior组合

4. **系统通知和事件**：
   - 监听`NSWorkspace.activeSpaceDidChangeNotification`
   - 使用`NSWorkspace.shared.frontmostApplication`检测当前环境
   - 动态调整窗口策略

5. **替代方案**：
   - 考虑使用NSPanel而不是NSWindow
   - 尝试不同的窗口样式和创建方式
   - 研究是否需要特殊的应用权限或配置

## 文件修改记录

### 主要修改文件
- `Sources/main.swift`：WindowManager类的showCaptureWindow()和positionWindowNearMouse()方法

### 关键修改点
1. 第38行：窗口级别从`.popUpMenu`改为`.modalPanel`
2. 第37行：从`window?.center()`改为`positionWindowNearMouse()`
3. 第57-128行：新增完整的屏幕检测和窗口定位逻辑

## 总结

### ✅ 已解决的问题
1. **窗口层级**：能够覆盖全屏应用显示
2. **鼠标附近定位**：窗口准确显示在鼠标附近
3. **物理多屏支持**：正确检测鼠标所在的显示器
4. **位置闪现问题**：窗口直接在正确位置创建，无跳跃效果

---

## 🎉 最终成功解决方案（2025-08-23 最新）

### 问题根因分析

经过深入研究发现，这不是坐标或屏幕检测问题，而是**窗口类型+应用激活策略**的问题：

- **核心问题**：常规`NSWindow`属于"普通App窗口"，在**别的App的全屏Space**上会被系统隐藏
- **系统限制**：macOS的全屏Space有特殊的窗口隔离机制，普通窗口无法跨越到其他应用的全屏空间
- **解决思路**：需要把弹窗做成**非激活Panel（NSPanel）**，并让应用以**Accessory/Agent**身份呈现该面板

### 最终解决方案

基于社区开源经验（Stack Overflow, Hammerspoon等项目）的成熟方案：

#### 核心技术栈
1. **NSWindow → NSPanel**：使用非激活面板避免抢夺焦点
2. **动态激活策略**：显示时切换到`.accessory`，隐藏时恢复`.regular`
3. **CGShieldingWindowLevel**：使用比`.screenSaver`更高的窗口层级
4. **Panel特殊配置**：浮动面板+跨Space行为

#### 关键代码实现

**1. 添加CoreGraphics导入**
```swift
import CoreGraphics  // 支持CGShieldingWindowLevel()
```

**2. Panel构造函数**
```swift
private func makeCapturePanel(frame: NSRect, content: NSView) -> NSPanel {
    let panel = NSPanel(
        contentRect: frame,
        styleMask: [.nonactivatingPanel, .titled, .closable], // 非激活 + 可关闭标题栏
        backing: .buffered,
        defer: false
    )
    panel.isFloatingPanel = true
    panel.hidesOnDeactivate = false
    panel.becomesKeyOnlyIfNeeded = true   // 需要交互时可成为 key
    panel.worksWhenModal = true
    panel.contentView = content

    // 加入所有 Spaces，且不随 Mission Control 切换位置抖动
    panel.collectionBehavior = [.canJoinAllSpaces, .stationary]

    // 关键：更高的窗口层级。优先尝试"屏蔽层级+1"，失败则回退到 screenSaver
    let shield = Int(CGShieldingWindowLevel())
    if shield > 0 {
        panel.level = NSWindow.Level(rawValue: shield + 1)
    } else {
        panel.level = .screenSaver
    }
    return panel
}
```

**3. 修改显示逻辑**
```swift
func showCaptureWindow() {
    print("🪟 显示捕获窗口")
    
    // 1) 显示前切到 accessory（Agent）以允许覆盖他人全屏 Space
    NSApp.setActivationPolicy(.accessory)  // 关键一步
    
    if let w = window {
        w.orderFrontRegardless()           // 面板用这个更稳定
        return
    }
    
    let captureView = CaptureWindow(
        onClose: { [weak self] in self?.hideCaptureWindow() },
        onMinimize: { [weak self] in self?.minimizeCaptureWindow() }
    )
    let targetFrame = calculateWindowPosition()
    let panel = makeCapturePanel(frame: targetFrame,
                                 content: NSHostingView(rootView: captureView))
    panel.title = "Context Collector"

    // 2) 直接前置到最前，无需激活其他 App
    panel.orderFrontRegardless()
    self.window = panel

    print("✅ 捕获窗口已显示（Accessory + Panel + ShieldLevel）")
}
```

**4. 修改隐藏逻辑**
```swift
func hideCaptureWindow() {
    print("🙈 隐藏捕获窗口")
    window?.orderOut(nil)
    window = nil

    // 3) 关闭后切回常规，以恢复 Dock 图标/常规行为
    NSApp.setActivationPolicy(.regular)
}
```

### 技术原理解释

#### 为什么之前的方案失败？
- `NSWindow + .screenSaver + .canJoinAllSpaces`对**同App自己的全屏**能起作用
- 但对**别的App的全屏**，系统会隐藏普通窗口，这就是"只在Space 1出现"的根因
- `.fullScreenAuxiliary`只对同App的全屏窗口起辅助作用，对"别的App的全屏"无效

#### 成功方案的关键点
1. **NSPanel的特殊性**：非激活面板不会抢夺焦点，可以浮在其他应用之上
2. **Accessory激活策略**：应用以辅助身份运行，允许覆盖其他应用的全屏Space
3. **CGShieldingWindowLevel**：提供了比标准层级更高的显示优先级
4. **动态策略切换**：保持正常的Dock图标体验，同时获得跨Space能力

### 🎯 最终测试结果

#### ✅ 完全解决的问题
1. **桌面Space显示**：✅ 工作正常
2. **全屏IDEA Space显示**：✅ 完美显示并浮在最前
3. **全屏Chrome Space显示**：✅ 完美显示并浮在最前
4. **鼠标附近定位**：✅ 窗口准确显示在鼠标附近
5. **物理多屏支持**：✅ 正确检测鼠标所在的显示器
6. **窗口交互**：✅ 保持所有原有功能（编辑、保存、快捷键等）
7. **Dock图标**：✅ 通过动态策略切换保持正常体验

#### 🔧 技术改进点
- **应用稳定性**：无崩溃，所有功能正常
- **用户体验**：在所有Space中都能正常使用
- **代码质量**：基于成熟的社区方案，无私有API依赖
- **系统兼容**：符合macOS设计规范，无审核风险

### 📚 宝贵经验总结

#### 关键技术洞察
1. **窗口类型选择**：NSPanel比NSWindow更适合跨Space显示
2. **激活策略重要性**：`.accessory`是覆盖全屏Space的关键
3. **层级理解**：`CGShieldingWindowLevel`是真正的最高层级
4. **API组合效应**：单一属性无法解决，需要多个技术点配合

#### 调试方法论
1. **问题本质分析**：不要被表象迷惑，深入理解系统机制
2. **社区方案研究**：开源项目是宝贵的经验来源
3. **系统性测试**：在真实的多Space环境中验证
4. **逐步验证**：分步骤验证每个技术点的效果

#### 对其他开发者的建议
1. **优先使用Panel**：对于工具类弹窗，NSPanel是更好的选择
2. **研究成功案例**：Rectangle、Hammerspoon等项目有很多可借鉴的技术
3. **理解系统限制**：macOS的Space隔离机制需要特殊的技术方案
4. **动态策略切换**：可以在保持用户体验的同时获得系统级能力

### 📊 技术状态总结

- **代码稳定性**：✅ 应用运行稳定，无崩溃
- **功能完整性**：✅ 所有预期功能正常工作
- **跨Space支持**：✅ 核心问题完全解决
- **用户体验**：✅ 在所有场景下都有良好体验
- **维护性**：✅ 基于标准API，便于后续维护

---

## 历史问题回顾

### ✅ 已完全解决的问题
1. **窗口层级**：能够覆盖全屏应用显示
2. **鼠标附近定位**：窗口准确显示在鼠标附近
3. **物理多屏支持**：正确检测鼠标所在的显示器
4. **位置闪现问题**：窗口直接在正确位置创建，无跳跃效果
5. **🎉 Mission Control Spaces显示问题**：窗口能在所有Space中正常显示

### 🔍 问题演进历程
- **阶段1**：误认为是物理多显示器问题
- **阶段2**：发现是Mission Control Spaces问题
- **阶段3**：尝试各种NSWindow配置方案均失败
- **阶段4**：深入研究系统机制，发现窗口类型和激活策略是关键
- **阶段5**：采用NSPanel + Accessory策略，完全解决问题

---

*最后更新：2025年8月23日*  
*当前状态：✅ 所有核心问题已完全解决*  
*解决方案：NSPanel + Accessory激活策略 + CGShieldingWindowLevel + 动态策略切换*