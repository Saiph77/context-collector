# Context Collector 多屏显示问题记录

## 问题描述

**目标**：让Context Collector窗口显示在鼠标当前所在的屏幕上，而不是总是显示在主屏幕上。

**现状**：窗口始终在主屏幕显示，即使鼠标在其他屏幕（如外接显示器）上时也是如此。

## 已尝试的解决方案

### 1. 提升窗口级别 ✅ 成功
**问题**：窗口无法显示在全屏应用（如IDEA）之上
**解决方案**：将窗口级别从`.popUpMenu`提升为`.modalPanel`
```swift
// 文件：Sources/main.swift:38
// 修改前：
window?.level = .popUpMenu

// 修改后：
window?.level = .modalPanel
```
**结果**：成功解决，窗口现在可以显示在全屏应用之上

### 2. 实现鼠标附近定位 ✅ 成功
**问题**：窗口总是居中显示，不在鼠标附近
**解决方案**：替换`window?.center()`为自定义的`positionWindowNearMouse()`方法
```swift
// 文件：Sources/main.swift:37
// 修改前：
window?.center()

// 修改后：
positionWindowNearMouse()
```
**结果**：成功实现窗口在鼠标附近显示

### 3. 屏幕检测问题 ❌ 未解决

#### 尝试方案一：修复NSMouseInRect参数
**假设**：`NSMouseInRect`的第三个参数（坐标系统翻转）可能导致检测错误
```swift
// 修改前：
let currentScreen = NSScreen.screens.first { screen in
    NSMouseInRect(mouseLocation, screen.frame, false)
} ?? NSScreen.main ?? NSScreen.screens.first!

// 修改后：
let currentScreen = NSScreen.screens.first { screen in
    screen.frame.contains(mouseLocation)
} ?? NSScreen.main ?? NSScreen.screens.first!
```
**结果**：未解决问题

#### 尝试方案二：双重检测策略
**假设**：可能需要分别检测`visibleFrame`和`frame`
```swift
// 使用更直接的方法获取鼠标所在屏幕
var currentScreen: NSScreen?
for screen in NSScreen.screens {
    // 使用visibleFrame进行检测，这更准确反映实际可用区域
    if screen.visibleFrame.contains(mouseLocation) {
        currentScreen = screen
        break
    }
}

// 如果在visibleFrame中没找到，再用frame试试
if currentScreen == nil {
    for screen in NSScreen.screens {
        if screen.frame.contains(mouseLocation) {
            currentScreen = screen
            break
        }
    }
}

// 最后的回退选项
if currentScreen == nil {
    currentScreen = NSScreen.main ?? NSScreen.screens.first!
}
```
**结果**：仍未解决问题

## 当前代码状态

### 完整的positionWindowNearMouse方法
```swift
private func positionWindowNearMouse() {
    guard let window = window else { return }
    
    // 获取当前鼠标位置
    let mouseLocation = NSEvent.mouseLocation
    print("🖱️ 鼠标位置: \(mouseLocation)")
    
    // 使用更直接的方法获取鼠标所在屏幕
    var currentScreen: NSScreen?
    for screen in NSScreen.screens {
        // 使用visibleFrame进行检测，这更准确反映实际可用区域
        if screen.visibleFrame.contains(mouseLocation) {
            currentScreen = screen
            break
        }
    }
    
    // 如果在visibleFrame中没找到，再用frame试试
    if currentScreen == nil {
        for screen in NSScreen.screens {
            if screen.frame.contains(mouseLocation) {
                currentScreen = screen
                break
            }
        }
    }
    
    // 最后的回退选项
    if currentScreen == nil {
        currentScreen = NSScreen.main ?? NSScreen.screens.first!
    }
    
    print("🖥️ 检测到的屏幕: \(currentScreen!.visibleFrame)")
    print("🖥️ 主屏幕对比: \(NSScreen.main?.visibleFrame ?? NSRect.zero)")
    
    // 窗口尺寸
    let windowSize = window.frame.size
    
    // 使用检测到的屏幕的可见区域进行定位
    let screenFrame = currentScreen!.visibleFrame
    
    // 计算目标位置（鼠标右下方偏移）
    let offset: CGFloat = 20
    var targetX = mouseLocation.x + offset
    var targetY = mouseLocation.y - windowSize.height - offset
    
    // 边界检测 - X轴
    if targetX + windowSize.width > screenFrame.maxX {
        // 如果右侧超出边界，放到鼠标左侧
        targetX = mouseLocation.x - windowSize.width - offset
    }
    if targetX < screenFrame.minX {
        // 如果左侧也超出，就居中到当前屏幕
        targetX = screenFrame.midX - windowSize.width / 2
    }
    
    // 边界检测 - Y轴
    if targetY < screenFrame.minY {
        // 如果下方超出边界，放到鼠标上方
        targetY = mouseLocation.y + offset
    }
    if targetY + windowSize.height > screenFrame.maxY {
        // 如果上方也超出，就居中到当前屏幕
        targetY = screenFrame.midY - windowSize.height / 2
    }
    
    let targetFrame = NSRect(x: targetX, y: targetY, width: windowSize.width, height: windowSize.height)
    window.setFrame(targetFrame, display: true)
    
    print("✅ 窗口定位到: \(targetFrame)")
    print("📍 是否在检测屏幕内: \(screenFrame.intersects(targetFrame))")
}
```

## 核心技术难点和疑惑

### 1. 坐标系统问题
- **macOS屏幕坐标系统**：原点在左下角，Y轴向上为正
- **NSEvent.mouseLocation**：返回全局屏幕坐标
- **NSScreen.frame vs visibleFrame**：frame包含菜单栏等，visibleFrame是实际可用区域
- **疑问**：不确定多屏环境下这些坐标系统如何协调工作

### 2. 屏幕检测方法
尝试过的方法：
- `NSMouseInRect(mouseLocation, screen.frame, false)`
- `screen.frame.contains(mouseLocation)`
- `screen.visibleFrame.contains(mouseLocation)`

**所有方法都无法正确检测鼠标所在的非主屏幕**

### 3. 调试信息缺失
- 添加了详细的print语句，但无法看到控制台输出来验证检测逻辑
- 不确定`NSEvent.mouseLocation`在多屏环境下返回的具体坐标值
- 不确定`NSScreen.screens`中各屏幕的frame/visibleFrame的具体值

## 可能的原因分析

### 1. 坐标系统转换问题
可能需要进行坐标系统转换，特别是在多屏环境下，不同屏幕可能有不同的坐标基准点。

### 2. 屏幕排列配置
macOS中屏幕的物理排列可能影响坐标计算，主屏幕不一定是坐标原点。

### 3. API使用错误
可能需要使用其他API，如：
- `NSScreen.deepest(for: point)`
- 或者通过`CGWindowListCopyWindowInfo`等底层API

### 4. 时机问题
可能在窗口创建的时机进行屏幕检测存在问题，需要在不同的生命周期阶段进行检测。

## 建议进一步调查的方向

1. **研究macOS多屏坐标系统**：深入了解多屏环境下的坐标转换机制
2. **使用专门的屏幕检测API**：如`NSScreen.deepest(for:)`方法
3. **添加实时调试**：创建能显示坐标信息的调试界面
4. **参考其他应用**：研究其他支持多屏的macOS应用如何实现
5. **考虑使用Core Graphics**：可能需要使用更底层的CG API进行屏幕检测

## 文件修改记录

### 主要修改文件
- `Sources/main.swift`：WindowManager类的showCaptureWindow()和positionWindowNearMouse()方法

### 关键修改点
1. 第38行：窗口级别从`.popUpMenu`改为`.modalPanel`
2. 第37行：从`window?.center()`改为`positionWindowNearMouse()`
3. 第57-128行：新增完整的屏幕检测和窗口定位逻辑

## 总结

虽然成功解决了窗口层级和鼠标附近定位的问题，但**多屏检测的核心问题仍未解决**。窗口依然只在主屏幕显示，无法根据鼠标位置切换到相应的屏幕。

这可能需要对macOS的多屏幕坐标系统有更深入的理解，或者使用不同的API方法来实现屏幕检测。

---

*记录时间：2025年8月23日*
*状态：问题未解决，需要进一步技术指导*