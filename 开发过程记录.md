# Context Collector 开发过程记录

## 项目概述

**项目名称**: Context Collector  
**开发时间**: 2025年8月23日  
**开发环境**: macOS 15.5, Swift 6.1.2  
**目标**: 实现一个快速文本收集和编辑的macOS应用  

## 核心需求分析

### 用户需求
- 双击 `⌘C` 全局快捷键触发
- 快速收集剪贴板内容并编辑
- 按项目和时间自动归档文件
- 支持Markdown格式编辑
- 类似macOS Finder的项目选择界面

### 技术约束
- 纯Swift + SwiftUI实现
- 需要macOS辅助功能权限
- 文件系统作为数据存储
- 单文件应用包部署

## 开发历程

### 第一阶段：环境搭建和需求确认 (12:10-12:20)

**任务**:
- 分析用户提供的需求文档
- 搭建开发环境
- 确认技术可行性

**成果**:
- ✅ 创建项目结构
- ✅ 确认Swift开发环境可用
- ✅ 制定详细开发计划

**经验**:
- 前期需求分析很重要，避免后期频繁修改
- 技术栈确认(Swift + SwiftUI)符合macOS原生开发最佳实践

### 第二阶段：核心功能模块开发 (12:20-12:50)

#### 2.1 文件系统访问测试
**挑战**: 验证Swift能否正常访问文件系统
**解决方案**: 
```swift
let homeDirectory = FileManager.default.homeDirectoryForCurrentUser
try FileManager.default.createDirectory(at: targetDir, withIntermediateDirectories: true)
```

**学到的经验**:
- FileManager是Swift中处理文件操作的标准方式
- 原子写入使用临时文件+重命名的方式保证数据完整性

#### 2.2 全局快捷键监听实现
**最大挑战**: 实现双击 `⌘C` 的全局监听

**技术方案**:
```swift
let eventTap = CGEvent.tapCreate(
    tap: .cgSessionEventTap,
    place: .headInsertEventTap,
    options: .defaultTap,
    eventsOfInterest: CGEventMask(eventMask),
    callback: hotkeyCallback,
    userInfo: selfReference
)
```

**困难点**:
- CGEventTap需要辅助功能权限
- 双击时间窗口检测逻辑复杂
- 回调函数中的内存管理

**解决方案**:
- 使用时间戳差值检测双击 (阈值0.4秒)
- Unmanaged指针管理避免内存泄漏
- 权限检查和错误处理

#### 2.3 剪贴板服务实现
**功能**: 读取各种格式的剪贴板内容

**技术实现**:
```swift
// 优先级: 纯文本 > RTF > HTML
if let plainText = pasteboard.string(forType: .string) {
    return plainText
}
// RTF转换...
// HTML转换...
```

**学到的经验**:
- macOS剪贴板支持多种数据格式
- 需要处理格式转换和降级策略

### 第三阶段：SwiftUI界面开发 (12:50-13:20)

#### 3.1 基础窗口实现
**挑战**: 创建浮动窗口并集成SwiftUI

```swift
window = NSWindow(
    contentRect: NSRect(x: 0, y: 0, width: 600, height: 450),
    styleMask: [.titled, .closable],
    backing: .buffered,
    defer: false
)
window?.level = .floating  // 保持最前
```

#### 3.2 macOS风格侧边栏设计
**需求**: 实现类似Finder的项目选择器

**设计挑战**:
- 蓝色高亮选中效果
- 项目图标和hover效果
- 响应式布局

**最终实现**:
```swift
struct ProjectSidebarItem: View {
    private var backgroundColor: Color {
        if isSelected {
            return Color.accentColor  // 系统蓝色
        } else if isHovered {
            return Color(NSColor.controlAccentColor).opacity(0.2)
        } else {
            return Color.clear
        }
    }
}
```

**学到的经验**:
- SwiftUI的Color.accentColor自动适配系统主题
- 使用@State管理hover状态需要onHover修饰符

#### 3.3 自定义文本编辑器
**挑战**: SwiftUI的TextEditor功能有限，需要自定义

**解决方案**: NSViewRepresentable包装NSTextView
```swift
struct CustomTextEditor: NSViewRepresentable {
    func makeNSView(context: Context) -> NSScrollView {
        let textView = NSTextView()
        textView.font = NSFont.monospacedSystemFont(ofSize: 13)
        // 配置等宽字体用于代码编辑
    }
}
```

### 第四阶段：存储系统实现 (13:00-13:10)

#### 4.1 目录结构设计
```
~/ContextCollector/
├── inbox/YYYY-MM-DD/
└── projects/{project}/YYYY-MM-DD/
```

#### 4.2 文件命名策略
- 格式: `HH-mm_title.md`
- 冲突处理: 添加`-a`, `-b`后缀
- 字符清洗: 替换非法字符为`-`

**关键代码**:
```swift
func resolveNameConflict(at url: URL) -> URL {
    for i in 1...26 {
        let suffix = String(UnicodeScalar(96 + i)!) // a,b,c...
        let newURL = directory.appendingPathComponent("\(base)-\(suffix).\(ext)")
        if !FileManager.default.fileExists(atPath: newURL.path) {
            return newURL
        }
    }
}
```

### 第五阶段：应用打包和权限处理 (13:10-13:40)

#### 5.1 应用包创建
**挑战**: Swift脚本无法获得辅助功能权限

**解决方案**: 创建标准macOS应用包结构
```
Context Collector.app/
├── Contents/
│   ├── Info.plist
│   └── MacOS/
│       └── ContextCollector
```

**Info.plist关键配置**:
```xml
<key>CFBundleIdentifier</key>
<string>com.contextcollector.v2.app</string>
<key>LSUIElement</key>
<true/>  <!-- 后台应用 -->
```

#### 5.2 权限问题诊断和解决
**最大困难**: 权限授予后仍无法正常工作

**问题分析过程**:
1. 权限检查脚本显示权限正常
2. 应用包运行时权限失效
3. 每次重编译后需重新授权

**根本原因**:
- 应用包重编译后，macOS认为是"新应用"
- Bundle ID和签名发生变化
- 系统权限列表中的条目失效

**解决流程**:
1. 完全移除旧的权限条目
2. 重新添加新编译的应用包
3. 确保选择.app文件而不是脚本

**调试方法**:
```swift
// 权限检查代码
let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): false]
let hasPermission = AXIsProcessTrustedWithOptions(options as CFDictionary)
```

### 第六阶段：Cmd+S快捷键集成 (13:20-13:30)

#### 6.1 窗口级键盘事件监听
**挑战**: 如何在SwiftUI中监听Cmd+S

**解决方案**: NSEvent本地监听
```swift
keyMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
    if event.modifierFlags.contains(.command) && event.charactersIgnoringModifiers == "s" {
        NotificationCenter.default.post(name: NSNotification.Name("SaveShortcut"), object: nil)
        return nil // 阻止事件传播
    }
    return event
}
```

**SwiftUI集成**:
```swift
.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("SaveShortcut"))) { _ in
    saveContent()
}
```

## 技术难点总结

### 1. macOS权限系统复杂性
**问题**: 辅助功能权限在开发过程中频繁失效  
**解决**: 建立权限诊断和重新授权流程  
**经验**: 每次重编译都可能需要重新授权

### 2. Swift脚本 vs 应用包的差异
**问题**: 同样的代码在脚本和应用包中表现不同  
**解决**: 统一使用应用包部署  
**经验**: 生产环境应使用标准应用包格式

### 3. SwiftUI与AppKit混合开发
**问题**: SwiftUI某些功能需要AppKit补充  
**解决**: NSViewRepresentable桥接  
**经验**: 复杂UI组件可能需要混合框架

### 4. 全局事件监听的稳定性
**问题**: CGEventTap在某些情况下失效  
**解决**: 添加错误检查和恢复机制  
**经验**: 系统级功能需要完善的错误处理

## 架构设计经验

### 模块化设计
最终采用单文件架构，包含以下模块：
- `ClipboardService` - 剪贴板操作
- `HotkeyService` - 全局快捷键
- `StorageService` - 文件存储
- `CaptureWindow` - 主界面
- `CaptureWindowManager` - 窗口管理

**优点**: 部署简单，依赖清晰  
**缺点**: 单文件较大，不利于协作开发

### 错误处理策略
```swift
enum ContextCollectorError: LocalizedError {
    case permissionDenied
    case fileWriteError(underlying: Error)
    case invalidProjectName(String)
    // ...
}
```

### 状态管理
使用SwiftUI的@State和@Published进行状态管理：
```swift
@State private var selectedProject: String?
@State private var saveStatus: SaveStatus = .idle
```

## 性能优化

### 1. 文件操作优化
- 使用原子写入避免数据损坏
- 异步执行文件I/O操作
- 缓存项目列表避免频繁扫描

### 2. UI响应性
- 使用DispatchQueue.main确保UI更新在主线程
- 长时间操作显示loading状态
- 合理使用@State避免不必要的重绘

### 3. 内存管理
- 及时释放大文本内容
- 使用弱引用避免循环引用
- 正确管理NSEvent监听器生命周期

## 部署和分发

### 应用包结构
```
Context Collector.app/
├── Contents/
│   ├── Info.plist          # 应用信息和权限声明
│   ├── MacOS/
│   │   └── ContextCollector # 可执行文件
│   └── Resources/          # 资源文件(暂未使用)
```

### 编译和部署脚本
```bash
#!/bin/bash
# rebuild-app.sh
swiftc -o "Context Collector.app/Contents/MacOS/ContextCollector" ContextCollectorV3.swift
```

## 未解决的问题

### 1. 权限持久化问题
**现状**: 每次重编译需要重新授权  
**影响**: 开发测试效率低  
**可能解决方案**: 
- 使用开发者证书签名
- 固定Bundle ID
- 构建CI/CD流程

### 2. 全局快捷键冲突
**现状**: 双击Cmd+C可能与其他应用冲突  
**影响**: 用户体验不一致  
**可能解决方案**:
- 提供自定义快捷键设置
- 增加冲突检测机制
- 提供替代触发方式

### 3. 性能优化空间
**现状**: 大文本处理可能卡顿  
**影响**: 用户体验  
**可能解决方案**:
- 异步文本处理
- 文本虚拟化
- 内存池优化

## 开发工具和环境

### 开发环境
- **操作系统**: macOS 15.5
- **开发工具**: Xcode Command Line Tools
- **Swift版本**: 6.1.2
- **编辑器**: Claude Code + Terminal

### 调试工具
- `ps aux | grep ContextCollector` - 进程监控
- 系统偏好设置 - 权限管理
- Console.app - 系统日志查看
- Activity Monitor - 资源使用监控

### 版本管理
- 采用文件命名版本控制 (V1, V2, V3)
- 保留关键版本的完整代码
- 及时清理测试和调试文件

## 学到的最佳实践

### 1. 权限处理
- 在应用启动时检查权限状态
- 提供清晰的权限引导界面
- 建立权限问题诊断流程

### 2. 错误处理
- 使用Swift的Error协议统一错误处理
- 为用户提供有意义的错误信息
- 建立完善的日志记录机制

### 3. 用户体验
- 保持界面简洁直观
- 提供即时反馈(成功/失败状态)
- 遵循macOS设计规范

### 4. 代码组织
- 模块化设计，职责清晰
- 使用清晰的命名约定
- 及时添加文档注释

## 项目总结

Context Collector项目从需求分析到完成开发，总共耗时约1.5小时，经历了多个版本迭代。最大的挑战是macOS权限系统的复杂性和调试难度。

### 成功的地方
- ✅ 完整实现了用户需求的核心功能
- ✅ 建立了完善的权限处理流程
- ✅ 创建了符合macOS规范的用户界面
- ✅ 实现了稳定的文件存储系统

### 需要改进的地方
- ❌ 权限问题导致的反复调试
- ❌ 缺少自动化测试覆盖
- ❌ 没有实现应用签名和分发

### 下一步计划
如果继续开发，建议优先处理：
1. 解决权限持久化问题
2. 添加用户配置界面
3. 实现更丰富的编辑功能
4. 添加单元测试和集成测试
5. 准备App Store分发

## 第七阶段：关键问题解决和代码重构 (15:30-17:00)

### 7.1 剪贴板读取失效问题
**问题现象**: 应用无法读取剪贴板内容，编辑器显示空白
**调试发现**: 缺少剪贴板访问权限声明
**解决方案**: 在Info.plist中添加NSAppleEventsUsageDescription权限
```xml
<key>NSAppleEventsUsageDescription</key>
<string>Context Collector needs permission to access clipboard content for text collection.</string>
```

### 7.2 Cmd+B快捷键失效问题
**问题根因**: NSMenuItem的keyEquivalent只在右键菜单中生效，不会全局响应
**第一次尝试**: 创建CustomTextView子类替换documentView
**致命错误**: 替换documentView破坏了SwiftUI的文本绑定机制
**现象**: 快捷键工作但剪贴板内容无法显示

### 7.3 文本绑定机制深度理解
**核心发现**: SwiftUI的@Binding机制依赖特定的NSTextView实例
**错误模式**: 
```swift
// ❌ 错误: 替换documentView破坏绑定
let customTextView = CustomTextView()
scrollView.documentView = customTextView
```

**正确模式**:
```swift  
// ✅ 正确: 保持原有documentView
let scrollView = NSTextView.scrollableTextView()
let textView = scrollView.documentView as! NSTextView
```

### 7.4 代码重构 - 模块化设计
**动机**: 458行的CaptureWindow.swift文件过大，难以维护
**重构策略**: 按组件职责拆分为多个文件

**重构前**:
```
Sources/CaptureWindow.swift (458行)
├── CaptureWindow struct
├── ProjectButton struct  
├── NewProjectDialog struct
└── AdvancedTextEditor struct + Coordinator class
```

**重构后**:
```
Sources/Views/
├── CaptureWindow.swift (250行) - 主窗口逻辑
├── AdvancedTextEditor.swift (118行) - 文本编辑器
├── ProjectComponents.swift (43行) - 项目相关组件
└── NewProjectDialog.swift (45行) - 新建项目对话框
```

**重构原则**:
- 保持所有功能完全不变
- 每个文件职责单一
- 维持完整的依赖关系
- 先创建新文件，再删除旧文件

### 7.5 快捷键与剪贴板冲突解决
**核心挑战**: 实现全局快捷键同时不破坏文本绑定
**多次尝试记录**:

**尝试1**: CustomTextView替换documentView
```swift
// ❌ 破坏文本绑定
let customTextView = CustomTextView()
scrollView.documentView = customTextView
```
**结果**: 快捷键工作，剪贴板失效

**尝试2**: Method Swizzling运行时修改
```swift  
// ❌ 过于复杂且不安全
let keyDownMethod = class_getInstanceMethod(NSTextView.self, #selector(NSTextView.keyDown(_:)))
```
**结果**: 技术风险太高，放弃

**尝试3**: NSEvent全局监听器 (最终方案)
```swift
// ✅ 最终成功方案
NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
    if event.window == textView.window && textView.window?.firstResponder == textView {
        // 处理快捷键
        return nil // 吞掉事件
    }
    return event // 继续传递
}
```

### 7.6 完整解决方案架构
**最终实现特点**:
1. **保持原生NSTextView**: 不替换documentView，保护文本绑定
2. **精确事件过滤**: 只处理来自目标textView的键盘事件  
3. **安全的全局监听**: 使用NSEvent.addLocalMonitorForEvents
4. **完整快捷键支持**: Cmd+B, Cmd+Z, Cmd+Shift+Z全部工作

**技术优势**:
- 不破坏SwiftUI绑定机制
- 不使用危险的runtime修改
- 精确的事件范围控制
- 易于理解和维护

## 关键踩坑记录

### 🚨 坑1: 替换documentView破坏文本绑定
**错误**: 为了添加快捷键功能，创建新的NSTextView实例替换原有的documentView
**后果**: SwiftUI的@Binding机制失效，剪贴板内容无法显示
**教训**: NSViewRepresentable中的NSView实例不能随意替换，SwiftUI依赖特定实例进行数据绑定

### 🚨 坑2: NSMenuItem的keyEquivalent作用域误解
**错误**: 认为NSMenuItem的keyEquivalent会全局生效
**真相**: keyEquivalent只在菜单激活时（右键菜单）生效
**教训**: 全局快捷键需要使用NSEvent监听或performKeyEquivalent重写

### 🚨 坑3: 权限声明不完整
**错误**: 只添加了NSAccessibilityUsageDescription，忽略了剪贴板权限
**后果**: 应用无法读取剪贴板内容
**教训**: macOS权限系统复杂，需要为每个系统功能添加对应权限声明

### 🚨 坑4: 功能冲突的调试盲区
**问题**: 添加快捷键功能后剪贴板失效，但编译无错误
**盲区**: 没有意识到两个功能之间存在代码层面的冲突
**教训**: 功能性问题可能不会产生编译错误，需要系统性分析代码变更影响

## 深度技术经验总结

### SwiftUI + AppKit混合开发
1. **NSViewRepresentable的限制**: 不能随意替换wrapped view实例
2. **数据绑定机制**: @Binding依赖特定的NSView实例引用
3. **事件处理**: SwiftUI和AppKit的事件系统需要协调配合

### macOS权限系统
1. **权限声明**: Info.plist中需要为每个系统功能添加说明
2. **权限检查**: 运行时动态检查权限状态
3. **权限调试**: 重编译后可能需要重新授权

### 全局事件监听
1. **事件范围控制**: 使用窗口和firstResponder精确过滤
2. **事件传递**: 正确处理事件吞掉(return nil)和继续传递(return event)
3. **内存管理**: 及时移除事件监听器避免内存泄漏

### 代码重构最佳实践
1. **小步快走**: 每次只重构一个组件，立即测试
2. **功能保持**: 重构过程中保持所有功能完全不变
3. **依赖管理**: 仔细处理模块间的依赖关系
4. **版本控制**: 重构前后都要提交git版本

## Git版本管理记录

项目采用完整的git版本控制，关键节点：

```bash
03f9257 修复剪贴板读取问题 - 版本保存点
dffe79c 代码重构 - 拆分CaptureWindow.swift为多个文件  
bdbec1f 修复快捷键功能 - 实现全局键盘事件拦截
[最新] 完整功能版本 - 剪贴板+快捷键完美共存
```

**版本管理经验**:
- 每个重要节点都要提交保存点
- 提交信息要详细说明问题和解决方案
- 保持版本历史的可追溯性

## 最终技术栈和架构

### 技术栈
- **语言**: Swift 6.1.2
- **UI框架**: SwiftUI + AppKit (NSViewRepresentable)
- **系统API**: Carbon (CGEventTap), Cocoa (NSEvent, NSTextView)
- **权限**: Accessibility + AppleEvents
- **存储**: FileManager (文件系统)

### 架构模式
- **MVC变体**: SwiftUI View + Coordinator + Service层
- **模块化**: 按功能拆分的多文件结构
- **事件驱动**: 全局快捷键 + 本地事件监听
- **数据绑定**: SwiftUI @Binding + NSTextViewDelegate

### 最终项目结构
```
Sources/
├── Views/
│   ├── CaptureWindow.swift      - 主窗口和业务逻辑
│   ├── AdvancedTextEditor.swift - 文本编辑器+快捷键处理  
│   ├── ProjectComponents.swift  - 项目选择组件
│   └── NewProjectDialog.swift   - 新建项目对话框
├── ClipboardService.swift       - 剪贴板读取服务
├── HotkeyService.swift         - 全局快捷键服务
├── StorageService.swift        - 文件存储服务
└── main.swift                  - 应用程序入口
```

---

**开发者**: Claude (Anthropic)  
**项目开始**: 2025年8月23日 12:10  
**MVP完成**: 2025年8月23日 13:41  
**完整版完成**: 2025年8月23日 17:00  
**项目状态**: ✅ 功能完整，剪贴板+快捷键完美共存