# Context Collector 开发过程记录

## 项目概述

**项目名称**: Context Collector  
**开发时间**: 2025年8月23日  
**开发环境**: macOS 15.5, Swift 6.1.2  
**目标**: 实现一个快速文本收集和编辑的macOS应用  

## 核心需求分析

### 用户需求
- 双击 `⌘C` 全局快捷键触发
- 快速收集剪贴板内容并编辑
- 按项目和时间自动归档文件
- 支持Markdown格式编辑
- 类似macOS Finder的项目选择界面

### 技术约束
- 纯Swift + SwiftUI实现
- 需要macOS辅助功能权限
- 文件系统作为数据存储
- 单文件应用包部署

## 开发历程

### 第一阶段：环境搭建和需求确认 (12:10-12:20)

**任务**:
- 分析用户提供的需求文档
- 搭建开发环境
- 确认技术可行性

**成果**:
- ✅ 创建项目结构
- ✅ 确认Swift开发环境可用
- ✅ 制定详细开发计划

**经验**:
- 前期需求分析很重要，避免后期频繁修改
- 技术栈确认(Swift + SwiftUI)符合macOS原生开发最佳实践

### 第二阶段：核心功能模块开发 (12:20-12:50)

#### 2.1 文件系统访问测试
**挑战**: 验证Swift能否正常访问文件系统
**解决方案**: 
```swift
let homeDirectory = FileManager.default.homeDirectoryForCurrentUser
try FileManager.default.createDirectory(at: targetDir, withIntermediateDirectories: true)
```

**学到的经验**:
- FileManager是Swift中处理文件操作的标准方式
- 原子写入使用临时文件+重命名的方式保证数据完整性

#### 2.2 全局快捷键监听实现
**最大挑战**: 实现双击 `⌘C` 的全局监听

**技术方案**:
```swift
let eventTap = CGEvent.tapCreate(
    tap: .cgSessionEventTap,
    place: .headInsertEventTap,
    options: .defaultTap,
    eventsOfInterest: CGEventMask(eventMask),
    callback: hotkeyCallback,
    userInfo: selfReference
)
```

**困难点**:
- CGEventTap需要辅助功能权限
- 双击时间窗口检测逻辑复杂
- 回调函数中的内存管理

**解决方案**:
- 使用时间戳差值检测双击 (阈值0.4秒)
- Unmanaged指针管理避免内存泄漏
- 权限检查和错误处理

#### 2.3 剪贴板服务实现
**功能**: 读取各种格式的剪贴板内容

**技术实现**:
```swift
// 优先级: 纯文本 > RTF > HTML
if let plainText = pasteboard.string(forType: .string) {
    return plainText
}
// RTF转换...
// HTML转换...
```

**学到的经验**:
- macOS剪贴板支持多种数据格式
- 需要处理格式转换和降级策略

### 第三阶段：SwiftUI界面开发 (12:50-13:20)

#### 3.1 基础窗口实现
**挑战**: 创建浮动窗口并集成SwiftUI

```swift
window = NSWindow(
    contentRect: NSRect(x: 0, y: 0, width: 600, height: 450),
    styleMask: [.titled, .closable],
    backing: .buffered,
    defer: false
)
window?.level = .floating  // 保持最前
```

#### 3.2 macOS风格侧边栏设计
**需求**: 实现类似Finder的项目选择器

**设计挑战**:
- 蓝色高亮选中效果
- 项目图标和hover效果
- 响应式布局

**最终实现**:
```swift
struct ProjectSidebarItem: View {
    private var backgroundColor: Color {
        if isSelected {
            return Color.accentColor  // 系统蓝色
        } else if isHovered {
            return Color(NSColor.controlAccentColor).opacity(0.2)
        } else {
            return Color.clear
        }
    }
}
```

**学到的经验**:
- SwiftUI的Color.accentColor自动适配系统主题
- 使用@State管理hover状态需要onHover修饰符

#### 3.3 自定义文本编辑器
**挑战**: SwiftUI的TextEditor功能有限，需要自定义

**解决方案**: NSViewRepresentable包装NSTextView
```swift
struct CustomTextEditor: NSViewRepresentable {
    func makeNSView(context: Context) -> NSScrollView {
        let textView = NSTextView()
        textView.font = NSFont.monospacedSystemFont(ofSize: 13)
        // 配置等宽字体用于代码编辑
    }
}
```

### 第四阶段：存储系统实现 (13:00-13:10)

#### 4.1 目录结构设计
```
~/ContextCollector/
├── inbox/YYYY-MM-DD/
└── projects/{project}/YYYY-MM-DD/
```

#### 4.2 文件命名策略
- 格式: `HH-mm_title.md`
- 冲突处理: 添加`-a`, `-b`后缀
- 字符清洗: 替换非法字符为`-`

**关键代码**:
```swift
func resolveNameConflict(at url: URL) -> URL {
    for i in 1...26 {
        let suffix = String(UnicodeScalar(96 + i)!) // a,b,c...
        let newURL = directory.appendingPathComponent("\(base)-\(suffix).\(ext)")
        if !FileManager.default.fileExists(atPath: newURL.path) {
            return newURL
        }
    }
}
```

### 第五阶段：应用打包和权限处理 (13:10-13:40)

#### 5.1 应用包创建
**挑战**: Swift脚本无法获得辅助功能权限

**解决方案**: 创建标准macOS应用包结构
```
Context Collector.app/
├── Contents/
│   ├── Info.plist
│   └── MacOS/
│       └── ContextCollector
```

**Info.plist关键配置**:
```xml
<key>CFBundleIdentifier</key>
<string>com.contextcollector.v2.app</string>
<key>LSUIElement</key>
<true/>  <!-- 后台应用 -->
```

#### 5.2 权限问题诊断和解决
**最大困难**: 权限授予后仍无法正常工作

**问题分析过程**:
1. 权限检查脚本显示权限正常
2. 应用包运行时权限失效
3. 每次重编译后需重新授权

**根本原因**:
- 应用包重编译后，macOS认为是"新应用"
- Bundle ID和签名发生变化
- 系统权限列表中的条目失效

**解决流程**:
1. 完全移除旧的权限条目
2. 重新添加新编译的应用包
3. 确保选择.app文件而不是脚本

**调试方法**:
```swift
// 权限检查代码
let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): false]
let hasPermission = AXIsProcessTrustedWithOptions(options as CFDictionary)
```

### 第六阶段：Cmd+S快捷键集成 (13:20-13:30)

#### 6.1 窗口级键盘事件监听
**挑战**: 如何在SwiftUI中监听Cmd+S

**解决方案**: NSEvent本地监听
```swift
keyMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
    if event.modifierFlags.contains(.command) && event.charactersIgnoringModifiers == "s" {
        NotificationCenter.default.post(name: NSNotification.Name("SaveShortcut"), object: nil)
        return nil // 阻止事件传播
    }
    return event
}
```

**SwiftUI集成**:
```swift
.onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("SaveShortcut"))) { _ in
    saveContent()
}
```

## 技术难点总结

### 1. macOS权限系统复杂性
**问题**: 辅助功能权限在开发过程中频繁失效  
**解决**: 建立权限诊断和重新授权流程  
**经验**: 每次重编译都可能需要重新授权

### 2. Swift脚本 vs 应用包的差异
**问题**: 同样的代码在脚本和应用包中表现不同  
**解决**: 统一使用应用包部署  
**经验**: 生产环境应使用标准应用包格式

### 3. SwiftUI与AppKit混合开发
**问题**: SwiftUI某些功能需要AppKit补充  
**解决**: NSViewRepresentable桥接  
**经验**: 复杂UI组件可能需要混合框架

### 4. 全局事件监听的稳定性
**问题**: CGEventTap在某些情况下失效  
**解决**: 添加错误检查和恢复机制  
**经验**: 系统级功能需要完善的错误处理

## 架构设计经验

### 模块化设计
最终采用单文件架构，包含以下模块：
- `ClipboardService` - 剪贴板操作
- `HotkeyService` - 全局快捷键
- `StorageService` - 文件存储
- `CaptureWindow` - 主界面
- `CaptureWindowManager` - 窗口管理

**优点**: 部署简单，依赖清晰  
**缺点**: 单文件较大，不利于协作开发

### 错误处理策略
```swift
enum ContextCollectorError: LocalizedError {
    case permissionDenied
    case fileWriteError(underlying: Error)
    case invalidProjectName(String)
    // ...
}
```

### 状态管理
使用SwiftUI的@State和@Published进行状态管理：
```swift
@State private var selectedProject: String?
@State private var saveStatus: SaveStatus = .idle
```

## 性能优化

### 1. 文件操作优化
- 使用原子写入避免数据损坏
- 异步执行文件I/O操作
- 缓存项目列表避免频繁扫描

### 2. UI响应性
- 使用DispatchQueue.main确保UI更新在主线程
- 长时间操作显示loading状态
- 合理使用@State避免不必要的重绘

### 3. 内存管理
- 及时释放大文本内容
- 使用弱引用避免循环引用
- 正确管理NSEvent监听器生命周期

## 部署和分发

### 应用包结构
```
Context Collector.app/
├── Contents/
│   ├── Info.plist          # 应用信息和权限声明
│   ├── MacOS/
│   │   └── ContextCollector # 可执行文件
│   └── Resources/          # 资源文件(暂未使用)
```

### 编译和部署脚本
```bash
#!/bin/bash
# rebuild-app.sh
swiftc -o "Context Collector.app/Contents/MacOS/ContextCollector" ContextCollectorV3.swift
```

## 未解决的问题

### 1. 权限持久化问题
**现状**: 每次重编译需要重新授权  
**影响**: 开发测试效率低  
**可能解决方案**: 
- 使用开发者证书签名
- 固定Bundle ID
- 构建CI/CD流程

### 2. 全局快捷键冲突
**现状**: 双击Cmd+C可能与其他应用冲突  
**影响**: 用户体验不一致  
**可能解决方案**:
- 提供自定义快捷键设置
- 增加冲突检测机制
- 提供替代触发方式

### 3. 性能优化空间
**现状**: 大文本处理可能卡顿  
**影响**: 用户体验  
**可能解决方案**:
- 异步文本处理
- 文本虚拟化
- 内存池优化

## 开发工具和环境

### 开发环境
- **操作系统**: macOS 15.5
- **开发工具**: Xcode Command Line Tools
- **Swift版本**: 6.1.2
- **编辑器**: Claude Code + Terminal

### 调试工具
- `ps aux | grep ContextCollector` - 进程监控
- 系统偏好设置 - 权限管理
- Console.app - 系统日志查看
- Activity Monitor - 资源使用监控

### 版本管理
- 采用文件命名版本控制 (V1, V2, V3)
- 保留关键版本的完整代码
- 及时清理测试和调试文件

## 学到的最佳实践

### 1. 权限处理
- 在应用启动时检查权限状态
- 提供清晰的权限引导界面
- 建立权限问题诊断流程

### 2. 错误处理
- 使用Swift的Error协议统一错误处理
- 为用户提供有意义的错误信息
- 建立完善的日志记录机制

### 3. 用户体验
- 保持界面简洁直观
- 提供即时反馈(成功/失败状态)
- 遵循macOS设计规范

### 4. 代码组织
- 模块化设计，职责清晰
- 使用清晰的命名约定
- 及时添加文档注释

## 项目总结

Context Collector项目从需求分析到完成开发，总共耗时约1.5小时，经历了多个版本迭代。最大的挑战是macOS权限系统的复杂性和调试难度。

### 成功的地方
- ✅ 完整实现了用户需求的核心功能
- ✅ 建立了完善的权限处理流程
- ✅ 创建了符合macOS规范的用户界面
- ✅ 实现了稳定的文件存储系统

### 需要改进的地方
- ❌ 权限问题导致的反复调试
- ❌ 缺少自动化测试覆盖
- ❌ 没有实现应用签名和分发

### 下一步计划
如果继续开发，建议优先处理：
1. 解决权限持久化问题
2. 添加用户配置界面
3. 实现更丰富的编辑功能
4. 添加单元测试和集成测试
5. 准备App Store分发

---

**开发者**: Claude (Anthropic)  
**完成时间**: 2025年8月23日 13:41  
**项目状态**: MVP完成，待解决权限问题